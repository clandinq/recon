[["index.html", "A Short Programming Guide for Economics Research Chapter 1 This is a dummy chapter", " A Short Programming Guide for Economics Research César Landín 2023-04-13 Chapter 1 This is a dummy chapter "],["ggplot.html", "Chapter 2 Tips for using ggplot to generate publication-quality graphs 2.1 Plot margins 2.2 Axis labels 2.3 Legends 2.4 Number formatting functions 2.5 Multiplot figures", " Chapter 2 Tips for using ggplot to generate publication-quality graphs 2.1 Plot margins 2.1.1 Removing white space around the plot To remove the white space around the plot, set the plot margins equal to 0. The order is [top, right, bottom, left]. figure %&gt;% theme(plot.margin = margin(0, 0, 0, 0)) This setting is useful when working with package cowplot to generate multi-panel figures. cowplot::plot_grid often overlays panel labels on top of the figures, so you can add space to the top of the figure: plot_grid(g1 + theme(plot.margin = margin(t = 15)), g2 + theme(plot.margin = margin(t = 15)), nrow = 2) 2.1.2 Removing white space between axes and plot Sometimes it’s useful to reduce the distance between the plot and axis text. You can do this by reducing the top margin of the x-axis text and the right margin of the y-axis text: figure %&gt;% theme(axis.text.x = element_text(margin = margin(t = -5, r = 0, b = 0, l = 0)), axis.text.y = element_text(margin = margin(t = 0, r = -5, b = 0, l = 0))) 2.2 Axis labels 2.2.1 Removing axis labels When removing axis labels (for example, when dealing with dates in the x-axis), use labs(x = NULL) rather than labs(x = \"\"), as this eliminates the extra white space. figure %&gt;% labs(x = NULL) 2.3 Legends 2.3.1 Removing the legend title Legend titles are always redundant: if the figure is included in the paper or report, then the title and axis label give enough information; if the figure is in a presentation, the slide title and description along with axis labels provide enough information to understand what is being plotted. figure %&gt;% theme(legend.title = element_blank()) 2.3.2 Removing black boxes around legend keys Legend keys look much better without the black border surrounding them. This should be a standard for any figure. figure %&gt;% theme(legend.key = element_blank()) 2.3.3 Putting the legend inside the figure Useful for when there is a lot of blank space in the figure. figure %&gt;% theme(legend.position = c(0.75, 0.85)) 2.4 Number formatting functions You can save these functions in a script called number_functions.R and import them in each script where they’re needed, e.g.: source(here(&quot;scripts&quot;, &quot;programs&quot;, &quot;number_functions.R&quot;)) 2.4.1 Calculating the mean, median and standard deviation of a variable # Mean num_mean &lt;- function(df, variable, dig = 1) { df %&gt;% pull(eval(as.name(variable))) %&gt;% mean(na.rm = TRUE) %&gt;% round(digits = dig) } # Median num_median &lt;- function(df, variable, dig = 1) { df %&gt;% pull(eval(as.name(variable))) %&gt;% median(na.rm = TRUE) %&gt;% round(digits = dig) } # Standard deviation num_sd &lt;- function(df, variable, dig = 1) { df %&gt;% pull(eval(as.name(variable))) %&gt;% sd(na.rm = TRUE) %&gt;% round(digits = dig) } You can call these functions the following way: df %&gt;% num_mean(&quot;number_employees&quot;) 2.4.2 Checking if a number is an integer. This is used in the functions that print numbers to .tex files, since no decimals should be added after integers. num_int &lt;- function(x) { x == round(x) } 2.4.3 Number formatting function This function formats numbers with a standard number of digits and commas to present large and small numbers in a more readable format. How does this function work? First, the function calculates the number of digits the number should have to the right of the decimal point. For numbers from 1-9, three digits are assigned, two digits are assigned for numbers 10-99, one for 100-999, and no right digits for numbers equal or larger than 1,000. This function sets the maximum number of right digits as 3. Therefore, 0.0001 will display as 0.000. Once the number of right digits is defined, the number is formatted. Numbers smaller than 1 are padded if necessary to ensure that there are 3 right digits (e.g., 0.25 is formatted as 0.250). The default number of right digits can be overridden with the option override_right_digits. This function has the same name as scales::comma_format. However, this function has been superseded by scales::label_comma, so there are no issues with this user-defined function taking priority over scales::comma_format. comma_format &lt;- function(x, override_right_digits = NA) { # Calculate number of right digits if (x &lt;= 0) {num &lt;- 1} else {num &lt;- x} right_digits &lt;- 3 - floor(log10(abs(num))) if (right_digits &lt; 0) {right_digits &lt;- 0} if (right_digits &gt; 3) {right_digits &lt;- 3} if (!is.na(override_right_digits)) {right_digits &lt;- override_right_digits} # Calculate number of left digits left_digits &lt;- 4 + floor(log10(abs(num))) if (left_digits &lt;= 0) {left_digits &lt;- 1} # Format number proc_num &lt;- format(round(x, right_digits), nsmall = right_digits, digits = left_digits, big.mark = &quot;,&quot;) if (proc_num != &quot;0&quot; &amp; as.numeric(str_replace(proc_num, fixed(&quot;,&quot;), &quot;&quot;)) &lt; 1) { proc_num &lt;- str_pad(proc_num, right_digits + 2, &quot;right&quot;, &quot;0&quot;) } return(proc_num) } Here are a few examples of the output of this function: pacman::p_load(tidyverse) lapply(c(0.098, 0.11, 3.1233, 45.968, 1949), comma_format) %&gt;% unlist() ## [1] &quot;0.098&quot; &quot;0.110&quot; &quot;3.123&quot; &quot;45.97&quot; &quot;1,949&quot; 2.5 Multiplot figures 2.5.1 Auxiliary functions to remove figure components: axes, legend Functions: remove_axis_x &lt;- function(plot) { plot + theme(axis.title.x = element_blank(), axis.text.x = element_blank()) } remove_axis_y &lt;- function(plot) { plot + theme(axis.title.y = element_blank(), axis.text.y = element_blank()) } remove_legend &lt;- function(plot) { plot + theme(legend.position = &quot;none&quot;) } Usage: Let g1, g2 and g3 be three figures with the same x-axis. We can plot the three figures in one multipanel figure, removing the legend and x-axis from all but the bottom figure. plot_grid(g1 %&gt;% remove_legend() %&gt;% remove_axis_x(), g2 %&gt;% remove_legend() %&gt;% remove_axis_x(), g3, rel_heights = c(1, 1, 1), nrow = 3, axis = &quot;b&quot;, align = &quot;h&quot;) "],["generating-publication-quality-tables.html", "Chapter 3 Generating publication-quality tables 3.1 Guidelines for table formatting 3.2 An example using the iris dataset 3.3 Adjusting table size and position 3.4 Updating variable names and adding a caption and label 3.5 Final table formatting 3.6 Putting it all together 3.7 Preparing tables for presentations", " Chapter 3 Generating publication-quality tables This section introduces best practices for the presentation of tables in economics papers and explains the usage of functions that can generate formatted tables from R model objects. First, we give guidelines for table formatting adapted from the Journal of Political Economy’s manuscript preparation guide. Second, we construct a publication-quality table using custom functions that can be downloaded here. 3.1 Guidelines for table formatting 3.1.1 Horizontal and vertical lines Only three horizontal lines. Tables should be free of horizontal lines unless they indicate the structure of the data. All tables should have the three following horizontal lines: One under the title, above the column headings (LaTeX \\toprule) One between the column headings and the body of the table (LaTeX \\midrule) One at the bottom of the table (LaTeX \\bottomrule) No vertical lines. No vertical lines should be included in the table. 3.1.2 Column headings Brief column names. Column headings should identify the column as briefly as possible. Headings should contain any necessary symbols (%, $, etc.) or measurement abbreviations (cm, kg, etc.) that apply to the data in the column below. 3.1.3 Symbols No symbols in the table body. The body of the table should be free of symbols or measurement abbreviations (e.g. %, USD). Symbols should be included next to dependent variable names. Symbols should appear in the column head when they apply to all values in the column, or in the leftmost column when they apply to all values in a row. For example, balance tables where each row is a regression will include symbols in row headers; regression tables where each column is a regression will include symbols in column headers. 3.2 An example using the iris dataset The following sections show how to make a publication-quality table using the iris dataset. 3.2.1 Two simple models using the iris dataset First, we load the iris dataset that contains measurements of 4 attributes for 50 flowers from 3 different species. pacman::p_load(here, tidyverse, magrittr, fixest, modelsummary, kableExtra, scales) data(iris) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Then, we define two models using package fixest. Both contain species fixed effects and cluster their errors at the species level. m1 &lt;- feols(Petal.Width ~ Sepal.Length, fixef = &quot;Species&quot;, cluster = &quot;Species&quot;, data = iris) m2 &lt;- feols(Petal.Width ~ Sepal.Length + Sepal.Width, fixef = &quot;Species&quot;, cluster = &quot;Species&quot;, data = iris) 3.2.1.1 mshow: visualizing quickly regression outcomes Next, we introduce a function called mshow for visualizing quickly regression outcomes. This function is helpful when we want to quickly preview a model in R Studio’s Viewer window instead of having to export the model to LaTeX. mshow defines standard significance levels and omits all statistics but the number of observations. The function takes as an input a list with the models (or a single model), and can include additional input that is passed on to the modelsummary function (for example, including additional rows). Model 1 Model 2 Sepal.Length 0.145** 0.064 (0.033) (0.034) Sepal.Width 0.232 (0.146) Num.Obs. 150 150 3.2.1.2 Exporting the table to LaTeX We can export the previous table to latex with the following code: The previous table is far from being ready to include in a paper: it does not specify what the outcome variable is, the default variable names have not been replaced by more descriptive names, and it includes content that is better left for the footnote (significance notes). The next thing that should be done to format the table is to adjust the table size and position, since both of these issues are fixed earlier on in the LaTeX code. 3.3 Adjusting table size and position The functions float_here, adjust_box, adjust_height, and adjust_col_spacing are used to adjust the table size and position: float_here inserts the [H] option after \\begin{table} so that LaTeX does not reposition the tables. This function requires including \\usepackage{float} in the document preamble. adjust_box reduces the size of the table so that it fits within the text column width. This function requires including \\usepackage{adjustbox} in the document preamble. adjust_height is used to adjust the height of a table. This is useful when dealing with long tables that may not fit within the same page without further adjustment. This limits the table to a user-defined text height percentage (e.g. 70% of the text height). adjust_height requires the previous application of the adjust_box function. str_insert is an auxiliary function used to insert lines in tables. adjust_col_spacing defines column spacings. This can be used to increase the spacing between columns when a table looks cramped. Functions: float_here &lt;- function(table) { if (!suppressWarnings(str_detect(string = table, pattern = fixed(&quot;\\\\begin{table}[H]&quot;)))) { table %&lt;&gt;% str_replace(pattern = fixed(&quot;\\\\begin{table}&quot;), replacement = &quot;\\\\begin{table}[H]&quot;) } return(table) } adjust_box &lt;- function(table) { table %&gt;% str_replace(pattern = fixed(&quot;\\\\begin{tabular&quot;), replacement = &quot;\\\\adjustbox{max width=\\\\textwidth}{ \\n \\\\begin{tabular&quot;) %&gt;% str_replace(pattern = fixed(&quot;\\\\end{tabular}&quot;), replacement = &quot;\\\\end{tabular}}&quot;) } adjust_height &lt;- function(table, height) { table %&gt;% str_replace(pattern = fixed(&quot;\\\\adjustbox{max width=\\\\textwidth}&quot;), replacement = str_c(&quot;\\\\adjustbox{max totalheight=&quot;, height, &quot;\\\\textheight, max width=\\\\textwidth}&quot;)) } str_insert &lt;- function(table, pattern, insert, before = FALSE) { rep &lt;- ifelse(before, str_c(fixed(insert), &quot;\\n&quot;, fixed(pattern)), str_c(fixed(pattern), &quot;\\n&quot;, fixed(insert))) table %&gt;% str_replace(pattern = fixed(pattern), replacement = rep) } adjust_col_spacing &lt;- function(table, spacing) { table %&gt;% str_insert(pattern = &quot;\\\\centering&quot;, insert = str_c(&quot;\\\\setlength{\\\\tabcolsep}{&quot;, spacing, &quot;pt}&quot;)) } Usage: current_table %&gt;% float_here() %&gt;% adjust_box() %&gt;% adjust_height(0.7) %&gt;% adjust_col_spacing(16) %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_2.tex&quot;)) The effects of float_here, adjust_box, and adjust_height can only be seen when compiling the table. The wide column spacing specified by adjust_col_spacing can be observed when comparing with the previous table. 3.4 Updating variable names and adding a caption and label 3.4.1 Updating independent variable names To update independent variable names, you should define object called coef_names with the detailed independent variable names, and names equal to the original variable names (example beow). coef_map = coef_names is passed on to modelsummary, substituting the original variable names. coef_names &lt;- c(&quot;Sepal length&quot;, &quot;Sepal width&quot;) %&gt;% set_names(c(&quot;Sepal.Length&quot;, &quot;Sepal.Width&quot;)) current_table &lt;- mshow(model_list, coef_map = coef_names, output = &quot;latex&quot;) current_table %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_3.tex&quot;)) 3.4.2 Adding dependent variable names and model numbers The next step is to add dependent variable names and model numbers to the table. This can be done with function insert_col_numbers. The auxiliary function get_num_cols is defined later in this section. insert_col_numbers has a binary toggle (TRUE includes column numbers, FALSE omits them) so that the function can be included inside other functions. That way, column numbers can be inserted depending on the number of columns. Function: insert_col_numbers &lt;- function(table, col_numbers) { if (col_numbers) { table %&gt;% str_insert(pattern = &quot;\\\\midrule&quot;, insert = str_c(&quot;&amp; &quot;, paste(str_c(&quot;(&quot;, 1:get_num_cols(table), &quot;)&quot;), collapse = &quot; &amp; &quot;), &quot;\\\\\\\\&quot;), before = TRUE) } else { table } } Usage: To update dependent variable names, you should set the names of the list with the models equal to the dependent variable names. Then, you can apply the insert_col_numbers function to include column numbers: current_table &lt;- model_list %&gt;% set_names(c(&quot;Petal width&quot;, &quot;Petal width&quot;)) %&gt;% mshow(coef_map = coef_names, output = &quot;latex&quot;) current_table %&gt;% insert_col_numbers(col_numbers = TRUE) %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_4.tex&quot;)) 3.4.3 Adding a multicolumn title An alternative to the previous table is to add a multicolumn title that describes the dependent variable. This can be done with function multicol_title, which takes as an input the multicolumn title and has an option to add a horizontal line below the multicolumn title. The auxiliary function remove_names removes the stock model names to keep only the multicolumn title. Therefore, the model list should remain unnamed. This function depends on another auxiliary function, get_num_cols, which calculates the numbers of columns in the table. Functions: multicol_title &lt;- function(table, title, cline = FALSE) { proc_table &lt;- table %&gt;% str_insert(pattern = &quot;\\\\toprule&quot;, insert = str_c(&quot;&amp; \\\\multicolumn{&quot;, get_num_cols(table), &quot;}{c}{&quot;, title, &quot;} \\\\\\\\\\n%clh&quot;)) if (cline) { proc_table %&lt;&gt;% str_replace(pattern = &quot;%clh&quot;, replacement = str_c(fixed(&quot;\\\\\\\\cline{2-&quot;), get_num_cols(table) + 1, &quot;}&quot;)) } return(proc_table) } remove_names &lt;- function(table) { if (str_detect(table, &quot;Model 1&quot;)) { table %&gt;% str_replace(pattern = fixed(str_c(&quot;&amp; &quot;, str_c(&quot;Model &quot;, 1:get_num_cols(table), collapse = &quot; &amp; &quot;), &quot;\\\\\\\\\\n&quot;)), replacement = &quot;&quot;) } else { table } } get_num_cols &lt;- function(table) { pos_start &lt;- str_locate(table, fixed(&quot;tabular}[t]{&quot;))[2] + 1 # Get starting position of column alignment pos_end &lt;- str_sub(table, pos_start, pos_start + 15) %&gt;% # Extract end position str_locate(fixed(&quot;}&quot;)) pos_end &lt;- pos_end[1] + pos_start - 2 col_num &lt;- (str_sub(table, pos_start, pos_end) %&gt;% str_length()) - 1 # Exclude leftmost column return(col_num) } Usage: Remember not to name the model list when using a multicolumn title: current_table &lt;- model_list %&gt;% mshow(coef_map = coef_names, output = &quot;latex&quot;) current_table %&gt;% remove_names() %&gt;% multicol_title(&quot;Petal Width&quot;) %&gt;% insert_col_numbers(col_numbers = TRUE) %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_5.tex&quot;)) 3.4.4 Adding a caption and title to the table add_caption_label_center is used to add a caption to the table float and define the float label. The caption should be as concise as possible, and the float should have the file name as label to facilitate locating the table in the paper and results folders. This function also centers the table in the middle of the float. float_here is required before add_caption_label_center. Functions: add_caption_label_center &lt;- function(table, caption, label) { center &lt;- ifelse(str_detect(table, &quot;centering&quot;), &quot;&quot;, &quot;\\\\centering&quot;) table %&gt;% str_insert(pattern = &quot;\\\\begin{table}[H]&quot;, insert = str_c(&quot;\\\\caption{&quot;, caption, &quot;} \\n&quot;, &quot;\\\\label{tab:&quot;, label, &quot;}&quot;, center)) } Usage: current_table %&gt;% float_here() %&gt;% remove_names() %&gt;% multicol_title(&quot;Petal Width&quot;) %&gt;% insert_col_numbers(col_numbers = TRUE) %&gt;% add_caption_label_center(caption = &quot;Correlation Between Flower Petal Width and Sepal Length and Width&quot;, label = &quot;flower_table&quot;) %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_6.tex&quot;)) 3.5 Final table formatting 3.5.1 Updating the number of observations Two functions can help to update the number of observations: comma_numobs inserts a comma every three digits in the number of observations. The auxiliary function comma_format is used by this function. replace_numobs replaces “Num.Obs” with a custom text (e.g. “Number of observations” or “Number of firms”). Functions: comma_format &lt;- function(x, override_right_digits = NA) { # Calculate number of right digits if (x &lt;= 0) {num &lt;- 1} else {num &lt;- x} right_digits &lt;- 3 - floor(log10(abs(num))) if (right_digits &lt; 0) {right_digits &lt;- 0} if (right_digits &gt; 3) {right_digits &lt;- 3} if (!is.na(override_right_digits)) {right_digits &lt;- override_right_digits} # Calculate number of left digits left_digits &lt;- 4 + floor(log10(abs(num))) if (left_digits &lt;= 0) {left_digits &lt;- 1} # Format number proc_num &lt;- format(round(x, right_digits), nsmall = right_digits, digits = left_digits, big.mark = &quot;,&quot;) if (proc_num != &quot;0&quot; &amp; as.numeric(str_replace(proc_num, fixed(&quot;,&quot;), &quot;&quot;)) &lt; 1) { proc_num &lt;- str_pad(proc_num, right_digits + 2, &quot;right&quot;, &quot;0&quot;) } return(proc_num) } comma_numobs &lt;- function(models) { model_proc &lt;- models for (i in 1:length(model_proc)) { model_proc[[i]]$nobs &lt;- comma(model_proc[[i]]$nobs) } return(model_proc) } replace_numobs &lt;- function(table, text) { table %&gt;% str_replace(pattern = &quot;Num.Obs.&quot;, replacement = text) %&gt;% str_replace(pattern = &quot;Num. Obs.&quot;, replacement = text) } Usage: current_table &lt;- model_list %&gt;% comma_numobs() %&gt;% mshow(coef_map = coef_names, output = &quot;latex&quot;) current_table %&gt;% float_here() %&gt;% remove_names() %&gt;% multicol_title(&quot;Petal Width&quot;) %&gt;% insert_col_numbers(col_numbers = TRUE) %&gt;% add_caption_label_center(caption = &quot;Correlation Between Flower Petal Width and Sepal Length and Width&quot;, label = &quot;flower_table&quot;) %&gt;% replace_numobs(&quot;Number of observations&quot;) %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_7.tex&quot;)) 3.5.2 Inserting additional data rows Often it’s useful to insert additional rows with statistics, for example means and medians. You can feed modelsummary a dataframe with the desired content and add these rows below the number of observations. Example: # Define additional rows petal_mean &lt;- mean(iris$Petal.Width) %&gt;% comma_format() sepal_length_mean &lt;- mean(iris$Sepal.Length) %&gt;% comma_format() sepal_width_mean &lt;- mean(iris$Sepal.Width) %&gt;% comma_format() add_row &lt;- data.frame(rbind(c(&quot;Mean petal width&quot;, rep(petal_mean, 2)), c(&quot;Mean sepal length&quot;, rep(sepal_length_mean, 2)), c(&quot;Mean sepal width&quot;, rep(sepal_width_mean, 2)))) # Add rows to previous table current_table &lt;- model_list %&gt;% comma_numobs() %&gt;% mshow(coef_map = coef_names, add_rows = add_row, output = &quot;latex&quot;) current_table %&gt;% float_here() %&gt;% remove_names() %&gt;% multicol_title(&quot;Petal Width&quot;) %&gt;% insert_col_numbers(col_numbers = TRUE) %&gt;% add_caption_label_center(caption = &quot;Correlation Between Flower Petal Width and Sepal Length and Width&quot;, label = &quot;flower_table&quot;) %&gt;% replace_numobs(&quot;Number of observations&quot;) %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_8.tex&quot;)) 3.5.3 Distributing coefficient names over two rows Interactions of variables frequently generate excessively long variable names. One solution for this is to split the variable name in two and put the second part of the variable name in the next row. Function coef_two_rows can do this automatically; all this needs is for the interaction variable to include “times” between the two variables. Functions: coef_two_rows &lt;- function(table) { # Check number of string locations string_loc &lt;- str_locate_all(table, &quot;times&quot;)[[1]] num_locations &lt;- nrow(string_loc) # Generate temporary output output &lt;- table # Tag words tagged_string &lt;- &quot;REPtimes&quot; output %&lt;&gt;% str_replace_all(&quot;times&quot;, tagged_string) # Loop over string locations for (i in 1:nrow(string_loc)) { # Locate coefficient string to replace with &quot;&quot; pat_loc &lt;- str_locate(output, fixed(tagged_string))[1] # Locate lower row to replace with coefficient string upper_row &lt;- str_sub(output, pat_loc, str_length(output)) lower_row &lt;- upper_row %&gt;% str_sub(str_locate(upper_row, fixed(&quot;\\\\\\\\\\n &quot;))[2] + 1, str_length(upper_row)) # Define pattern to replace in upper row pat_rep_upper &lt;- str_split(upper_row, &quot;&amp;&quot;, n = 2)[[1]][1] # Define pattern to replace in lower row pat_rep_lower &lt;- lower_row %&gt;% str_sub(1, str_locate(lower_row, fixed(&quot;\\\\\\\\\\n&quot;))[2]) # Replace strings in table. output %&lt;&gt;% str_replace(pattern = pat_rep_upper, replacement = &quot;&quot;) %&gt;% str_replace(pattern = fixed(pat_rep_lower), replacement = str_c(&quot;\\\\quad $\\\\times$&quot;, str_replace(pat_rep_upper, tagged_string, &quot;&quot;), pat_rep_lower)) } return(output) } Usage: # Add new variable to dataset. set.seed(123) current_data &lt;- iris %&gt;% mutate(random = sample(0:1, nrow(.), replace = TRUE)) # Define model m3 &lt;- feols(Petal.Width ~ Sepal.Length * random, fixef = &quot;Species&quot;, cluster = &quot;Species&quot;, data = current_data) # Define coefficient names coef_names &lt;- c(&quot;Sepal length&quot;, &quot;Random variable&quot;, &quot;Sepal length times Random variable&quot;) %&gt;% set_names(c(&quot;Sepal.Length&quot;, &quot;random&quot;, &quot;Sepal.Length:random&quot;)) # Export table current_table &lt;- model_list %&gt;% append(list(m3)) %&gt;% comma_numobs() %&gt;% mshow(coef_map = coef_names, output = &quot;latex&quot;) current_table %&gt;% float_here() %&gt;% remove_names() %&gt;% multicol_title(&quot;Petal Width&quot;) %&gt;% insert_col_numbers(col_numbers = TRUE) %&gt;% add_caption_label_center(caption = &quot;Correlation Between Flower Petal Width and Sepal Length and Width&quot;, label = &quot;flower_table&quot;) %&gt;% replace_numobs(&quot;Number of observations&quot;) %&gt;% coef_two_rows() %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_9.tex&quot;)) 3.5.4 Inserting space between variables In tables with two-line variable names, it can be easier to read the table when there is sufficient spacing between each set of variable coefficient and standard errors. The function add_line_space inserts vertical space between each set of variable numbers and facilitates reading the table. Function: add_line_space &lt;- function(table) { # Keep split rows after first parentheses. keep_after_firstpar &lt;- (table %&gt;% str_sub(str_locate(table, fixed(&quot;(&quot;))[1], str_length(table)) %&gt;% str_split(&quot;\\\\\\n&quot;))[[1]] # Keep rows with parentheses. keep_after_firstpar &lt;- keep_after_firstpar[str_detect(keep_after_firstpar, fixed(&quot;(&quot;))] # Drop first one (column numbers) keep_after_firstpar &lt;- keep_after_firstpar[2:length(keep_after_firstpar)] # Replace with spacing. proc_table &lt;- table for (i in 1:length(keep_after_firstpar)) { proc_table %&lt;&gt;% str_replace(pattern = fixed(keep_after_firstpar[i]), replacement = str_c(keep_after_firstpar[i], &quot;[0.3cm]&quot;)) } return(proc_table) } Usage: current_table %&gt;% float_here() %&gt;% remove_names() %&gt;% multicol_title(&quot;Petal Width&quot;) %&gt;% insert_col_numbers(col_numbers = TRUE) %&gt;% add_caption_label_center(caption = &quot;Correlation Between Flower Petal Width and Sepal Length and Width&quot;, label = &quot;flower_table&quot;) %&gt;% replace_numobs(&quot;Number of observations&quot;) %&gt;% coef_two_rows() %&gt;% add_line_space() %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_10.tex&quot;)) 3.6 Putting it all together 3.6.1 Combining everything into one simple function Most of the previous tables can be combined into one simple function: gen_base_table. The only non-auxiliary functions that are not included by default in the options are adjust_height, adjust_col_spacing, coef_two_rows and add_line_space. Function: gen_base_table &lt;- function(models, caption, label, title = NULL, cline = FALSE, coef_names, numobs = &quot;Number of observations&quot;, ...) { # Get length of model. If large, it is a regression that needs to be put in a list if (length(models) &gt; 10) {models &lt;- list(models)} # Generate table output &lt;- models %&gt;% # Fix number of observation number format comma_numobs() %&gt;% # Generate table with modelsummary modelsummary(coef_map = coef_names, stars = c(&quot;*&quot; = .1, &quot;**&quot; = .05, &quot;***&quot; = 0.01), gof_omit = &quot;AIC|BIC|R2|R2 Adj.|R2 Pseudo|R2 Within|Log.Lik.|Std.Errors|FE|RMSE&quot;, escape = FALSE, output = &quot;latex&quot;, ...) %&gt;% # Insert float here option float_here() %&gt;% # Insert adjustbox adjust_box() %&gt;% # Add caption and label add_caption_label_center(caption = caption, label = label) %&gt;% # Insert column numbers insert_col_numbers(ifelse(length(models) == 1, FALSE, TRUE)) %&gt;% # Remove model names if no unique column names given remove_names() %&gt;% # Replace number of observations (Num.Obs. with Num. Obs.) replace_numobs(numobs) if (!is.null(title)) { output %&lt;&gt;% multicol_title(title, cline = cline) } return(output) } Usage: You can replicate the previous table with this simple command: model_list %&gt;% append(list(m3)) %&gt;% gen_base_table(caption = &quot;Correlation Between Flower Petal Width and Sepal Length and Width&quot;, label = &quot;flower_table&quot;, title = &quot;Petal Width&quot;, coef_names = coef_names) %&gt;% coef_two_rows() %&gt;% add_line_space() %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_11.tex&quot;)) 3.6.2 Adding footnotes The final step is to remove the notes from the bottom of the table and include our own footnote. You can do this with function format_save_footnote and including options(\"modelsummary_stars_note\" = FALSE) in your code. This function saves a footnote to a file with the same name as the table in the folder /results/notes. This makes it easier to locate notes and include them in the LaTeX document the following way: \\input{../results/tables/current_table.tex} \\input{../results/notes/current_table.tex} Usage Function: format_save_footnote &lt;- function(text = &quot;&quot;, filename, stars = FALSE) { sig &lt;- ifelse(stars, &quot; * $p &lt; 0.1$, ** $p &lt; 0.05$, *** $p &lt; 0.01$.&quot;, &quot;&quot;) footnote &lt;- str_c(&quot;\\\\footnotesize \\n&quot;, &quot;\\\\begin{justify} \\n&quot;, &quot;\\\\emph{Note}: &quot;, text, sig, &quot;\\n&quot;, &quot;\\\\end{justify} \\n&quot;, &quot;\\\\normalsize \\n&quot;) clean_filename &lt;- str_split(filename, fixed(&quot;.&quot;))[[1]][1] write(footnote, here(&quot;results&quot;, &quot;notes&quot;, str_c(clean_filename, &quot;.tex&quot;))) } Usage: options(&quot;modelsummary_stars_note&quot; = FALSE) # (generate previous table after running this line) paste(&quot;This table reports the correlation between petal width and sepal lenght and width.&quot;, &quot;The unit of observation is at the plant level.&quot;, &quot;The coefficients come from the regression of petal width on sepal length (column (1)), the regression of petal width on sepal length and sepal width (column (2)), and the regression of petal width on a random dummy variable, sepal length and the interaction between these two variables (column (3)).&quot;, &quot;Data comes from the iris dataset.&quot;, &quot;All estimations include species fixed effects, and standard errors clustered at the species level are included in parentheses.&quot;) %&gt;% format_save_footnote(&quot;current_table.tex&quot;, stars = TRUE) 3.7 Preparing tables for presentations Once you have generated a final version of the table, there are a few functions that can easily generate a presentation version of the table, remove unwanted rows and add short notes at the bottom of the table. 3.7.1 Generating presentation versions of tables Presentation versions of tables only include the content between \\begin{tabulate} and \\end{tabulate}. convert_save_pres_table can do this conversion rapidly. By default, this table looks for the input table in /results/tables, and saves the output to the same folder with the pres_ prefix. Function: convert_save_pres_table &lt;- function(table_name, table_path = here(&quot;results&quot;, &quot;tables&quot;), output_path = here(&quot;results&quot;, &quot;tables&quot;)) { table &lt;- read_file(here(table_path, table_name)) table &lt;- str_sub(table, str_locate(table, fixed(&quot;\\\\begin{tabular}&quot;))[1], str_locate(table, fixed(&quot;\\\\end{tabular}&quot;))[2]) pres_table_name &lt;- str_c(&quot;pres_&quot;, table_name) write(table, here(output_path, pres_table_name)) print(str_c(&quot;Presentation table saved to&quot;, str_remove(output_path, here()), &quot;/&quot;, pres_table_name)) } Usage: convert_save_pres_table(&quot;table_11.tex&quot;) 3.7.2 Removing standard errors and column numbers Removing standard errors and column numbers can make it easier to fit tables in presentations without having to reduce the font size too much. remove_std_errors_col_nums is another simple function with no options that can quickly perform this modification. Function: remove_std_errors_col_nums &lt;- function(table) { table %&gt;% str_split(&quot;\\n&quot;) %&gt;% .[[1]] %&gt;% .[!(str_detect(., fixed(&quot;(&quot;)))] %&gt;% str_c(collapse = &quot;\\n&quot;) } Usage: This would require saving a version of the original table without standard errors and column numbers, and then converting to a presentation version. The previous table would look like this: read_file(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_12.tex&quot;)) %&gt;% remove_std_errors_col_nums() %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_13.tex&quot;)) convert_save_pres_table(&quot;table_13.tex&quot;) ### 3.7.3 Adding notes Finally, although it’s best practice not to add notes directly to a table, it is the only way you can add a note to a presentation table (since footnotes can’t be included). add_note can be used for adding notes to presentation tables. Function: add_note &lt;- function(table, note) { table %&gt;% str_insert(pattern = &quot;\\\\bottomrule&quot;, insert = str_c(&quot;\\\\multicolumn{&quot;, get_num_cols(table) + 1, &quot;}{c}{&quot;, note, &quot;}&quot;)) } Usage: read_file(here(&quot;results&quot;, &quot;tables&quot;, &quot;pres_table_13.tex&quot;)) %&gt;% add_note(&quot;Quick note at the bottom of the presentation table.&quot;) %&gt;% write(here(&quot;results&quot;, &quot;tables&quot;, &quot;table_14.tex&quot;)) ### "],["post-regression-statistical-tests.html", "Chapter 4 Post-regression statistical tests 4.1 Easy two-sided hypothesis tests in R", " Chapter 4 Post-regression statistical tests In this section, we introduce functions for performing hypothesis tests on model coefficients using the multcomp package. We introduce a function called extract_test_coef that tests a hypothesis on model parameters and extracts the resulting p-values of the test. Then, we show the usage of the function with an example using the iris dataset. 4.1 Easy two-sided hypothesis tests in R First, load the required packages and the iris dataset. The packages needed are tidyverse for data manipulation, fixest for estimating models, modelsummary for displaying model results, multcomp for estimating hypothesis tests and conflicted to deal with conflicts in function names. With package conflicted, we can specify which package to use for a given function. Since multcomp and dplyr conflict in multiple functions, we can specify which package to use for each function and give preference to dplyr. The iris dataset contains measurements of 4 attributes for 50 flowers from 3 different species. # Load packages pacman::p_load(tidyverse, fixest, modelsummary, multcomp, conflicted, fastDummies) # Resolve conflicts conflict_prefer(&quot;select&quot;, &quot;dplyr&quot;) conflict_prefer(&quot;filter&quot;, &quot;dplyr&quot;) conflict_prefer(&quot;last&quot;, &quot;dplyr&quot;) # Load iris data data(iris) head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa Next, we define terciles of sepal width and a simple model using package fixest. We show the model results using the mshow function defined in the previous chapter. # Define terciles of sepal width proc_data &lt;- iris %&gt;% mutate(sepal_width_tercile = ntile(Sepal.Width, 3)) %&gt;% dummy_cols(&quot;sepal_width_tercile&quot;) # Define coefficient names coef_names &lt;- c(&quot;Sepal length&quot;, &quot;First tercile sepal width&quot;, &quot;Second tercile sepal width&quot;, &quot;Third tercile sepal width&quot;) %&gt;% set_names(c(&quot;Sepal.Length&quot;, str_c(&quot;sepal_width_tercile_&quot;, 1:3))) # Define model m1 &lt;- feols(Petal.Width ~ 0 + Sepal.Length + sepal_width_tercile_1 + sepal_width_tercile_2 + sepal_width_tercile_3, se = &quot;hetero&quot;, data = proc_data) mshow(list(&quot;Petal width&quot; = m1), coef_map = coef_names) Petal width Sepal length 0.732*** (0.041) First tercile sepal width −2.882*** (0.242) Second tercile sepal width −3.083*** (0.237) Third tercile sepal width −3.261*** (0.215) Num.Obs. 150 The next step is to use the function extract_test_coef to test two hypothesis: The effect of the first tercile of sepal width on petal width is equal to the effect of the second tercile of sepal width on petal width The effect of the first tercile of sepal width on petal width is equal to the effect of the third tercile of sepal width on petal width The function returns p-values for each test. The expression included in the function must be in the form coef_a == coef_b and will perform a two-sided hypothesis test where the null hypothesis is \\(H_0: coef_a = coef_b\\). # Define function extract_test_coef &lt;- function(model, comp) { expr &lt;- comp %&gt;% str_replace(pattern = fixed(&quot;==&quot;), replacement = &quot;-&quot;) res &lt;- model %&gt;% glht(linfct = str_c(expr, &quot;= 0&quot;)) %&gt;% confint() %&gt;% summary() return(as.numeric(res$test$pvalues)) } # Test hypotheses pval_1_2 &lt;- extract_test_coef(m1, &quot;sepal_width_tercile_1 == sepal_width_tercile_2&quot;) pval_1_3 &lt;- extract_test_coef(m1, &quot;sepal_width_tercile_1 == sepal_width_tercile_3&quot;) Finally, we add the p-values to the model results using the add_row argument of the mshow function. # Add p-values to model results add_row &lt;- tribble(~name, ~value, &quot;P-value (Sepal width 1st tercile = Sepal width 2nd tercile)&quot;, comma_format(pval_1_2), &quot;P-value (Sepal width 1st tercile = Sepal width 3rd tercile)&quot;, comma_format(pval_1_3)) mshow(list(&quot;Petal width&quot; = m1), coef_map = coef_names, add_row = add_row) Petal width Sepal length 0.732*** (0.041) First tercile sepal width −2.882*** (0.242) Second tercile sepal width −3.083*** (0.237) Third tercile sepal width −3.261*** (0.215) Num.Obs. 150 P-value (Sepal width 1st tercile = Sepal width 2nd tercile) 0.008 P-value (Sepal width 1st tercile = Sepal width 3rd tercile) 0.000 From the results of these hypotheses tests, we can reject the hypothesis that the effect of the first tercile of sepal width on petal width is equal to the effect of the second tercile of sepal width on petal width, and that the effect of the first tercile of sepal width on petal width is equal to the effect of the third tercile of sepal width on petal width. "],["geographic-place-matching.html", "Chapter 5 Geographic place matching 5.1 Google Places API searches", " Chapter 5 Geographic place matching In applied work, we often have to deal with observations that have an associated address or coordinates but no geographic codes. For cases in which no coordinates are available, one option is to match addresses to coordinates using Google Place API searches, and then merge the resulting coordinates with shapefiles to obtain geographic codes. 5.1 Google Places API searches R package googleway makes it easy to perform Google Place API searches. googleway::google_find_place generates a Find Place request, taking a text input and returning an array of place candidates, along with their corresponding search status. From this result, we can extract the address and coordinates. Currently, you get $200 of Google Maps Platform usage every month for free. Each request costs $0.017. While this may seem like little, generating 12,000 requests will already exceed the monthly free usage quota ($200 = 11,764.7 requests). It’s easy to exceed this number of requests when you’re running loops for large query vectors repeatedly. Therefore, the best practice is to start out with a small sample, ensure that searches are returning valid results, and then extend the method to the full sample. You can set a maximum quota of 375 requests per day (375 x 31 = 11,625) to ensure you don’t exceed the monthly free usage limit. To start using googleway to conduct Google Place API searches, you first need to create a Google Cloud project and set up an API key. Once you have set this up, you can load googleway, define the API key and start conducting searches. Here is a simple example of an individual query. pacman::p_load(here, tidyverse, googleway) # (1.1): Set Google Place search API key. key &lt;- &quot;KJzaLyCLI-nXPsHqVwz-jna1HYg2jKpBueSsTWs&quot; # insert API key here set_key(key) # (1.2): Define tibble with addresses to look up. missing_locs &lt;- tribble(~id, ~address, 1, &quot;Av. Álvaro Obregón 225, Roma Norte, Cuauhtémoc, CDMX, Mexico&quot;, 2, &quot;Río Hondo #1, Col. Progreso Tizapán, Álvaro Obregón, CDMX, México&quot;) # (1.3): Loop over missing addresses. loc_coords &lt;- tibble() for (i in 1:nrow(missing_locs)) { # Get results from Google Place search results &lt;- google_find_place(missing_locs$address[i], inputtype = &quot;textquery&quot;, language = &quot;es&quot;) # Print results search_status &lt;- ifelse(results[[&quot;status&quot;]] == &quot;OK&quot;, &quot;search successful&quot;, &quot;search returned no results&quot;) print(str_c(&quot;Working on address &quot;, i, &quot; out of &quot;, nrow(missing_locs), &quot;, &quot;, search_status)) # Extract formatted address and coordinates results clean_results &lt;- tibble(id = missing_locs$id[i], address_clean = results[[&quot;candidates&quot;]][[&quot;formatted_address&quot;]], loc_lat = results[[&quot;candidates&quot;]][[&quot;geometry&quot;]][[&quot;location&quot;]][[&quot;lat&quot;]], loc_lon = results[[&quot;candidates&quot;]][[&quot;geometry&quot;]][[&quot;location&quot;]][[&quot;lng&quot;]]) # Append to full results dataframe. loc_coords %&lt;&gt;% bind_rows(clean_results) } rm(results, clean_results, i, search_status) # (1.4): Keep first result for each address. clean_results %&lt;&gt;% group_by(id) %&gt;% slice(1) Once you finish your set of Google Place API requests, you should save the results to a CSV file for later use. The search process is not perfectly replicable as identical searches can produce different results over time, so you should only run your full search loop once. "]]
